<!DOCTYPE html>
<html>
  <head>
    <title>OpenSeadragon Example</title>
  </head>
  <body>
    Image 115200 x 55296
    <div id="openseadragon1" style="width: 800px; height: 600px"></div>

    <script src="openseadragon-bin-5.0.1/openseadragon.min.js"></script>

    <script type="module">

      import * as zarr from "https://cdn.jsdelivr.net/npm/zarrita@next/+esm";
      // import * as omezarr from "https://cdn.jsdelivr.net/npm/ome-zarr.js@latest/+esm";
      const omezarr = await import("/src/index.ts");

      const ZARR_URL =
        "https://storage.googleapis.com/jax-public-ngff/public/39287.zarr/0";
      const WIDTH = 115200;
      const HEIGHT = 55296;
      const TILE_SIZE = 1024;
      // NB: don't know how MAX_LEVEL is calculated, but for this image it's...
      const MAX_LEVEL = 17;  // At this level 1:1 with original image


      const storeBig = new zarr.FetchStore(ZARR_URL);

      let zarrArrays = {};

      for (let datasetResolution of [0, 1, 2, 3, 4, 5, 6]) {
        let omeZarrInfo = await omezarr.getMultiscaleWithArray(storeBig, datasetResolution);
        console.log("OME-Zarr info for resolution", datasetResolution, omeZarrInfo);
        zarrArrays["" + datasetResolution] = omeZarrInfo;
      }

      async function fetchTile(row, col, level, signal) {
        console.log("Fetching tile row", row, "col", col, "level", level);
        let xStart = col * TILE_SIZE;
        let yStart = row * TILE_SIZE;
        let sliceIndices = {
          "x": [xStart, Math.min(xStart + TILE_SIZE, WIDTH)],
          "y": [yStart, Math.min(yStart + TILE_SIZE, HEIGHT)]
        };
        let omeZarrInfo = zarrArrays[(level).toString()];
        // TODO: handle omeZarrInfo is undefined (level out of range)
        let bigArray = omeZarrInfo.arr;
        let dataUrl = await omezarr.renderImage(
          bigArray,
          omeZarrInfo.multiscale.axes,
          omeZarrInfo.omero,
          sliceIndices,
          false,
          undefined,
          { signal }
        );
        return dataUrl;
      }

      //see https://stackoverflow.com/questions/41996814/how-to-abort-a-fetch-request
      //we need to provide the possibility to abort fetch(...)
      function myFetch(input, init) {
        let controller = new AbortController();
        let signal = controller.signal;
        init = Object.assign({ signal }, init);
        let promise = fetch(input, init);
        promise.controller = controller;
        return promise;
      }

      OpenSeadragon.extend(OpenSeadragon.TileSource.prototype, {
        getTilePostData: function (level, x, y) {
          //here we exploit the POST API, a handy shortcut to pass ourselves
          //an instance to the tile object
          //return tile;
          return { width: this.getTileWidth(), height: this.getTileHeight() };
        },
        getTileAjaxHeaders: function (level, x, y) {
          // to avoid CORS problems
          return {
            "Content-Type": "application/octet-stream",
            "Access-Control-Allow-Origin": "*",
          };
        },
        downloadTileStart: function (imageJob) {
          //   console.log("Requesting tile imageJob", imageJob.src);

          let info = imageJob.src.split("#")[1];
          console.log("Requesting tile info", info);
          // namespace where we attach our properties to avoid
          // collision with API
          let context = imageJob.userData;
          context.abortController = new AbortController();
          context.image = new Image();

          // in all scenarios, unless abort() is called, make
          // sure imageJob.finish() gets executed!
          context.image.onerror = function (reason) {
            console.error("Error loading image:", reason);
            imageJob.finish(
              null,
              null,
              `Failed to parse tile data as an Image: ${reason}`
            );
          };
          context.image.onabort = function () {
            if (!context.abortController.signal.aborted) {
              context.abortController.abort();
            }
            console.warn(`Image loading aborted: ${context.abortController.signal.reason}`);
          };
          context.image.onload = function () {
            imageJob.finish(context.image, null, null);
          };

          function createErrorImageURL(e) {
            let canvas = document.createElement("canvas");
            let context = canvas.getContext("2d");

            //yay, postData = tile instance
            let tile = imageJob.postData;
            canvas.width = tile.width;
            canvas.height = tile.height;
            context.font = "24px Georgia";
            context.fillStyle = "#00ff00";
            context.fillText(info, 5, 120);
            return canvas.toDataURL("image/jpeg");
          }

          // note we ignore some imageJob properties such as
          // 'loadWithAjax'. This means preventing OSD from using
          // ajax will have no effect as we force it to do so.
          // Make sure you implement all the features the official
          // implementation do if you want to keep them.
        //   context.promise = myFetch(imageJob.src, {
        //     method: "GET",
        //     mode: "cors",
        //     cache: "no-cache",
        //     credentials: "same-origin",
        //     headers: imageJob.ajaxHeaders || {},
        //     body: null,
        //   })
        //     .then((data) => {
        //       //to spice up things, emulate faulty source
        //       if (Math.random() > 0.7) throw "Oh no!";
        //       return data.blob();
        //     })
        //     .then((blob) => {
        //       context.image.src = URL.createObjectURL(blob);
        //     })
        //     .catch((e) => {
        //       console.error("Error fetching tile:", e);
        //       context.image.src = createErrorImageURL(e);
        //     });

          fetchTile(
            parseInt(info.split("/")[2]),
            parseInt(info.split("/")[1]),
            MAX_LEVEL - parseInt(info.split("/")[0]),
            context.abortController.signal,
          )
          .then((dataURL) => {
            context.image.src = dataURL;
          })
          .catch((e) => {
            if (context.abortController.signal.aborted) {
              console.warn("Fetch aborted, not an error:", e);
            } else {
              console.error("Error fetching tile:", e);
              context.image.src = createErrorImageURL(e);
            }
          });
        },
        downloadTileAbort: function (imageJob) {
          context.abortController.abort();
          context.image.src = ""; // invokes onabort
        },
      });

      console.log("Creating viewer...");

      OpenSeadragon({
        id: "openseadragon1",
        prefixUrl: "./openseadragon-bin-5.0.1/images/",
        navigatorSizeRatio: 0.25,
        wrapHorizontal: false,
        loadTilesWithAjax: true, // no effect
        tileSources: {
          height: HEIGHT,
          width: WIDTH,
          tileSize: TILE_SIZE,
          minLevel: 12,
        //   maxLevel: 11,
          getTileUrl: function (level, x, y) {
            // The ZARR_URL is actually ignored.
            return ZARR_URL + "#" + level + "/" + x + "/" + y;
          },
        },
      });
    </script>
  </body>
</html>
